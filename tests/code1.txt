"""QUESTION"""
Q1: What does this code print?
"""CODE"""
void func(int arr[], int n) {
for (int i = 0; i < n; i++) {
arr[i] *= 2;
}
}
int main() {
int nums[3] = {1,2,3};
func(nums, 3);
for (int i = 0; i < 3; i++) {
cout << nums[i];
}
return 0;
}
"""CODE"""
"""CHOICES"""
A: 123
B: 246
C: 135
D: 222
"""ANSWER"""
B
"""QUESTION"""
Q2: What does this code print?
"""CODE"""
struct FruitBox {
string* fruits;
};
void fill_box(FruitBox& fb) {
fb.fruits = new string[2]{"apple", "orange"};
}
int main() {
FruitBox* box = new FruitBox;
fill_box(*box);
cout << (*box).fruits[0] << "," << (*box).fruits[1];
delete box;
return 0;
}
"""CODE"""
"""CHOICES"""
A: apple,orange
B: orange,apple
C: apple,apple
D: orange,orange
"""ANSWER"""
A
"""QUESTION"""
Q3: What does this code print? Does it have a memory leak?
"""CODE"""
int main() {
std::ifstream file("input.txt");
int* b = new int[3];
for(int i = 3; i > 0; i--){
file >> b[i-1];
}
for(int i = 0; i < 2; i++){
std::cout << b[i];
}
file.close();
delete [] b;
return 0;
}
Assume input.txt contains:
5
0
1
4
"""CODE"""
"""CHOICES"""
A: 50 with leak
B: 01 with leak
C: 50 no leak
D: 01 no leak
"""ANSWER"""
C
"""QUESTION"""
Q4: What does this code print?
"""CODE"""
void func(int* input1, int* input2) {
input1[2]++;
input2[3]++;
}
int main() {
int arr_a[] = {15, 14, 19, 21};
int* arr_b = new int[4]{5, 3, 7, -2};
func(arr_a, arr_b);
cout << arr_a[2] << "," << arr_b[3] << endl;
delete[] arr_b;
return 0;
}
"""CODE"""
"""CHOICES"""
A: 19,-2
B: 20,-1
C: 19,-1
D: 20,-2
"""ANSWER"""
B
"""QUESTION"""
Q5: What does this code print? Does it have a memory leak?
"""CODE"""
class classy{
private:
int data;
classy* ptr;
public:
classy(int x, classy* p): data(x), ptr(p) {}
~classy() {
cout << data;
delete ptr;
}
};
int main(){
classy* A = new classy(1, nullptr);
classy* B = new classy(2, A);
classy* C = new classy(3, A);
delete C;
}
"""CODE"""
"""CHOICES"""
A: 3 with leak
B: 31 with leak
C: 3 no leak
D: 31 no leak
"""ANSWER"""
B
"""QUESTION"""
Q6: Which rule-of-three function has a problem in this code?
"""CODE"""
class Set{
public:
int* items;
int size;
Set(): items(new int[3]{4,5,6}), size(3){}
Set(const Set& source): items(new int[source.size]), size(source.size) {
for(int i = 0; i < source.size; i++){
items[i] = source.items[i];
}
}
~Set(){ delete [] items; }
Set& operator=(const Set& source){
delete [] items;
items = new int[source.size];
for(int i = 0; i < source.size; i++){
items[i] = source.items[i];
}
size = source.size;
return *this;
}
};
"""CODE"""
"""CHOICES"""
A: Destructor
B: Copy constructor
C: Copy assignment
D: None
"""ANSWER"""
C
"""QUESTION"""
Q7: Using the Set class from Q6, what does this code print? Does it have a memory leak?
"""CODE"""
void modify(Set s){
s.items[1] = 2;
s.size = 2;
}
int main(){
Set numbers;
modify(numbers);
cout << numbers.items[1] << numbers.size;
}
"""CODE"""
"""CHOICES"""
A: 23 with leak
B: 53 with leak
C: 23 no leak
D: 53 no leak
"""ANSWER"""
D
"""QUESTION"""
Q8: What does this code print? Does it have a memory leak?
"""CODE"""
class Dinner{
int num_dishes;
public:
Dinner(int x): num_dishes(x) {}
Dinner(const Dinner& d): num_dishes(d.num_dishes) {}
int get_num_dishes(){ return num_dishes; }
~Dinner() {}
};
int main(){
Dinner d1(3);
Dinner d2(4);
d1 = d2;
Dinner d3 = d1;
cout << d3.get_num_dishes();
}
"""CODE"""
"""CHOICES"""
A: 4 with leak
B: 3 with leak
C: 4 no leak
D: 3 no leak
"""ANSWER"""
C
"""QUESTION"""
Q9: What does this code print? Does it have a memory leak?
"""CODE"""
class FruitBasket {
private:
string* fruitName;
int size;
public:
FruitBasket() : fruitName(new string("banana")), size(5) {
cout << "A";
}
FruitBasket(const FruitBasket& rhs) {
cout << "B";
}
~FruitBasket() {
cout << "C";
}
FruitBasket& operator=(const FruitBasket& rhs) {
cout << "D";
return *this;
}
};
int main() {
FruitBasket basket1;
FruitBasket basket2 = basket1;
basket1 = basket2;
}
"""CODE"""
"""CHOICES"""
A: ABCD with leak
B: ABD with leak
C: ABCD no leak
D: ABD no leak
"""ANSWER"""
A
"""QUESTION"""
Q10: What does this code print?
"""CODE"""
void func(int* x){
x[2] = 5;
x = &(x[2]);
}
int main(){
int arr[] = {2,4,6,8,10};
func(arr);
cout << arr[1] << arr[2];
}
"""CODE"""
"""CHOICES"""
A: 46
B: 45
C: 44
D: 56
"""ANSWER"""
B
"""QUESTION"""
Q11: What does this code print?
"""CODE"""
void func(char* x){
for(int i = 0; x[i] != '\0'; i++){
x[i] = x[i+1];
}
x = x+1;
}
int main(){
char* str = new char[10]{"Howdy!"};
func(str);
cout << str;
}
"""CODE"""
"""CHOICES"""
A: Howdy!
B: owdy!
C: wdy!
D: dy!
"""ANSWER"""
B
"""QUESTION"""
Q12: What does this code print?
"""CODE"""
void func(double*& x){
x[2] = 5;
x = new double[7]{};
}
int main(){
double* arr = new double[3]{1.62,2.72,3.14};
func(arr);
cout << arr[2];
}
"""CODE"""
"""CHOICES"""
A: 3.14
B: 5
C: 0
D: undefined
"""ANSWER"""
B
"""QUESTION"""
Q13: What does this code print? Does it have a memory leak?
"""CODE"""
int main(){
char* x = new char[3]{'a','b','c'};
char y[3]{'d','e','f'};
char* z = y;
z[1] = 'g';
cout << y[1];
z = x;
delete[] z;
x = nullptr;
z = nullptr;
}
"""CODE"""
"""CHOICES"""
A: g with leak
B: e with leak
C: g no leak
D: e no leak
"""ANSWER"""
C
"""QUESTION"""
Q14: At the commented line in Q13, where are each of these variables stored?
x
z
x[1]
z[1]
"""CODE"""
/* variables at this point:
x -> heap array
z -> points to y (stack)
x[1] -> heap
z[1] -> stack
*/
"""CODE"""
"""CHOICES"""
A: Heap,Stack,Heap,Stack
B: Heap,Stack,Stack,Heap
C: Stack,Heap,Heap,Stack
D: Stack,Stack,Stack,Heap
"""ANSWER"""
A
"""QUESTION"""
Q15: What does this code print? Does it have a memory leak? Is default construction possible?
"""CODE"""
class Letter{
char * ptr;
public:
Letter(char value) : ptr(new char(value)) { }
Letter(const Letter &other):ptr( new char( *(other.ptr))){}
void setValue(char value){
*ptr = value;
}
char getValue() const { return *ptr; }
};
ostream& operator<<(ostream& out, const Letter n) {
out << n.getValue();
return out;
}
int main() {
Letter L1('c');
Letter L2 = L1;
cout << L1 << L2;
L1.setValue('j');
cout << L1 << L2;
L2 = L1;
}
"""CODE"""
"""CHOICES"""
A: ccjjc with leak, default possible
B: ccjjc no leak, default impossible
C: ccjjc with leak, default impossible
D: ccjcc with leak, default impossible
"""ANSWER"""
C
"""QUESTION"""
Q16: What does this code print? Does it have a memory leak?
"""CODE"""
class Foo{
public:
int* a;
double* b;
Foo(int* aptr, double b): a(aptr), b(new double(b)) {}
~Foo(){
delete b;
}
Foo(const Foo& other){
a = other.a;
b = new double(other.b);
}
};
int main(){
int ptr = new int(7);
Foo pi(ptr, 3.14);
Foo e(ptr, 2.72);
Foo morePi = pi;
*ptr = 3;
*pi.b = 3.1415;
cout << *morePi.a << ", " << *morePi.b;
delete ptr;
}
"""CODE"""
"""CHOICES"""
A: 3, 3.1415 with leak
B: 7, 3.1415 with leak
C: 3, 3.1415 no leak
D: 7, 3.1415 no leak
"""ANSWER"""
A
"""QUESTION"""
Q17: What does this code print? Does it have a memory leak?
"""CODE"""
class Foo{
int* x;
public:
Foo(): x(new int(3)) {}
int& val(){
return x;
}
Foo(const Foo& other){
x = new int((other.x));
}
};
int main(){
Foo a,b;
a.val() = 4;
a = b;
b.val() = 5;
Foo c = a;
c.val() = 6;
cout << a.val() << b.val() << c.val();
}
"""CODE"""
"""CHOICES"""
A: 456 with leak
B: 356 with leak
C: 456 no leak
D: 356 no leak
"""ANSWER"""
B
"""QUESTION"""
Q18: What does this code print? Does it have a memory leak?
"""CODE"""
class Demo {
int *ptr;
public:
Demo(int num){
cout << "A";
ptr = new int(num);
}
Demo( const Demo &obj){
cout << "B";
ptr = new int;
*ptr = *obj.ptr;
}
~Demo(){
cout << "C";
delete ptr;
}
};
int main() {
Demo Demo1(10);
Demo Demo2(Demo1);
}
"""CODE"""
"""CHOICES"""
A: ABC with leak
B: AABCC no leak
C: ABCC no leak
D: ABC no leak
"""ANSWER"""
C
"""QUESTION"""
Q19: What does this code print? Does it have a memory leak?
"""CODE"""
class Foo{
public:
int* data;
Foo() : data(new int(5)) {}
Foo(const Foo& other){
data = new int(*other.data);
cout << "X";
}
~Foo(){
delete data;
cout << "Y";
}
Foo& operator=(const Foo& other){
data = new int(*other.data);
cout << "Z";
return *this;
}
};
int main(){
Foo a, b;
Foo c = a;
*a.data = 7;
cout << *c.data;
b = a;
}
"""CODE"""
"""CHOICES"""
A: X5Z with leak
B: X5Y no leak
C: X5Z no leak
D: X7Z no leak
"""ANSWER"""
C